
todo list를 만들때 고려해야할 것

브라우저의 작동방식 
사용자의 입력과 전송을 누르는 것 event, form tag(사용자의 입력 받음)
안에  input tag가 있어야댐 button 타입의 submit 입력하고 전송을 누르면
form 정보를 어딘가에 전송을 한다  action의 어딘가에 전송을 한다

폼 (form)

폼이란 사용자의 데이터를 서버에 전송하는 방법이다. 일반적으로 아래와 같은 작업을 하기 위해서는 폼을 이용한다.
로그인을 위해서 아이디/비밀번호를 입력할 때
회원가입을 하기 위해서 개인정보를 입력할 때
블로그나 게시판에 글을 작성하거나, 파일을 전송할 때

action : 사용자가 입력한 데이터를 전송할 서버의 URL
method : 사용자가 입력한 데이터를 전송하는 방법으로 아래와 같은 방식이 있다.
	get : action에 입력한 URL에 파라미터의 형태로 전송
      - URL 상에 파라미터를 표현할 때에는 '?' 앞뒤로 구분하여 앞에 것은 URL 뒤의 것은 파라미터이다.
      각각의 파라미터는 '&'로 구분하여 nickname과 job이라는 두개의 파라미터가 온 것을 알 수 있다.
      '='을 이용하여 파라미터와 파라미터의 값을 구분한다.
	post : header의 body에 포함해서 전송
      header의 body에 담겨서 전송된다.
      URL 상에 전달한 정보가 표시되지 않는다.
      GET에 비해서 보안상 약간의 우위에 있다. (사실상 동일하다)
      전송할 수 있는 데이터의 길이 제한이 없다.
      퍼머링크로 사용할 수 없다.
      서버 쪽에 어떤 작업을 명령할 때 사용한다.
      (데이터의 기록, 삭제, 수정 등)


https://devbox.tistory.com/entry/HTML5-a-%ED%83%9C%EA%B7%B8

질문 1 <input type="text" size="40" placeholder="Todo Item 내용을 입력해주세요" name= "query">
name = "query"가 의미하는게
<form name="appenderForm" action="https://search.naver.com/search.naver" method="GET">
여기 부분의 name을 가리켜서 들어가는 건가?요?

사용자의 입력을 받아서 전송을 하는 것 form tag의 역할 

<h1>📃 TodoList</h1>
    <form name="appenderForm" action="https://search.naver.com/search.naver" method="GET">
      <fieldset>
        <legend hidden>TodoList Form</legend>
        <label>
          <span hidden>아이템 추가</span>
          <input type="text" size="40" placeholder="Todo Item 내용을 입력해주세요" name= "query">
        </label>
        <button type="submit">전송</button>
      </fieldset>
    </form>

이런식의 응용도 가능 하다



//////////////////////////////////////////


// 1. dom 접근
//이벤트를 받아서 실행을 해야된다

document.forms;
//모든 폼들이 나와 수정을 하기위한 폼
//지금은 appendForm, modifierForm 두가지가 존재


// <form name="appenderForm" action="" method="post"> 여서
//자식 접근하는 것 마냥
//doc의 자식인 form의 자식 appendForm에 접근
document.forms.appendForm;

//form 의 name에 있는 appenderForm 을 가리키는 것



//<button type="submit">전송</button> 이 있어서 이것을 눌렀을때 (전송되었을때)
document.forms.appendForm.onsubmit;

//전송이 되었을 때 실행이 되는 것

// document.forms.appenderForm.onsubmit = 
// function(event) {
//     event.preventDefault();
//     alert('form이 전송되었습니다.');
// }

//event는 form에 대한 event 정보 이러한 api가 있는데
//브라우저에서 지정해준 고유 이벤트 (ex)네이버에전송)을 무시하고
//alert만 실행

document.body.getElementById('todoList')
<body>
body 태그 내부에서 id를 기반으로 해서 id가 todoList인것을 찾아라

document.getElementById('todoList')여기까지만 써도 실행이 가능

이렇게 실행을 하면 tag가 찍혀  <ul id="todoList">
이 tag한테 추가를 해주어야 함

var $newItem = document.createElement('li');
document.getElementById('todoList').appendChild($newItem);

todo 리스트라는 곳에 newItem을 추가를 한다.
$newItem을 추가 >> var은 변수
'li'태그 하나를 만들어 준다.

$newItem.innerHTML = `
        <p>
          4주차: 배포하기 >> ${event.target.querySelector('input').value}
        </p>
        <button type="button">완료</button>
        <button type="button">수정</button>
        <button type="button">삭제</button>
    `;

html태그를 입력해주면 됩니다요

${event.target.querySelector('input').value}
event.target

console.log(event);를 통해 어떠한 내용을 가지고 있나를 볼 수 있다.
event는 submitevent라는 객체 function (event) 함수의 매개변수로 받아온 것
이상태에서 target form tag의 정보

querySelector 선택하는 명령
querySelector('input').value; input tag에 입력을 한 값

event.target >> document.forms.appenderForm을 의미한다

document.forms.appenderForm.onsubmit = function (event) {
    ${event.target.querySelector('input').value}
이런식에서

var $appenderForm = document.forms.appenderForm;
$appenderForm.onsubmit = function (event) {
    ${$appenderForm.querySelector('input').value}

이벤트 등록 완료 submit이벤트 발생하였을때 event등록!

submit은 클릭이랑 enter로도 가능 >> form tag에 묶여있는 개념 /event
form tag한테만 submit을 줄 수 있다.

변수 앞 $ 는 태그를 선택한 것 ,, 대부분의 경우 태그이다.


//////////

var $todoList = document.querySelector('#todoList');

$todoList.appendChild($newItem);
document.getElementById('todoList').appendChild($newItem);
이렇게 해줌으로서 위와 아래가 기능이 같다.

$todoList.querySelectorAll('.remove')
.은 class 
<button type="button">삭제</button>
<button class="remove" type="button">삭제</button>


var $todoList = document.querySelector('#todoList');
$todoList.querySelectorAll('.remove')

querySelector 한개를 querySelectorAll 여러개를 선택
class는 묶음의 느낌 class는 여러개
현재 page에서 (html에서) id는 한개
todoList 단일 고유의 한개 태그를
todoList안의 remove들 여러개 선택

$todoList.querySelectorAll('.remove').forEach($remove => {
    $remove.parentNode.removeChild();
})

forEach는 각각에 대해서 실행
remove의 parentNode를 진짜 지운다
parentNode는 부모태그 li를 지운다.


 $todoList.querySelectorAll('.remove').forEach($remove => {
     $remove.onclick = function() {
     $remove.parentNode.remove();
     }
 })

>>아래로 수정
$todoList.querySelectorAll('.remove').forEach(
    function($remove) {
        $remove.onclick = function() {
            $remove.parentNode.remove();
        }
    }
)

remove class가 onclik 클릭이벤트가 발생했을때 다음 함수를 실행하라


일급 시민이 있다.
1. 변수에 저장할 수 있다.
2. 함수의 매개변수로 넘길 수 있다.
3. 함수의 리턴값을 반환 할 수 있다.

자바스크립트의 함수는 일급 시민이다.
1. 변수에 함수를 저장할 수 있다.

var a = function () {alert('안녕하세요)}

2. 함수의 매개변수로 넘길 수 있다.
function b(fn, n1, n2) { alert(fn(n1, n2)); }

//b(function (n1, n2) { return 'n1 = ${n1}, n2 = ${n2}'})

function add(n1, n2) { return n1 + n2 }
function sub(n1, n2) { return n1 + n2 }

b(add, 10, 20);
b라는 함수 안에서 add라는 함수를 실행하는 데 add라는 함수의 매개변수가 10, 20
b(sub, 10, 20);
b(sub, add(10, 20), 20);

$appenderForm.onsubmit = appendItem;
-------onsubmit이라는 변수에다가 appendItem 함수를 할당 1번에 해당

//forEach에 대해서 각각을 $remove
$todoList.querySelectorAll('.remove').forEach(
    function($remove) {
        $remove.onclick = function() {
            $remove.parentNode.remove();
        }
    }
)
------forEach라는 함수에다가 function이라는 익명함수를 넘겨준 것 2번에 해당

3. 함수의 리턴값으로 함수로 반환할 수 있다.

function add (n1) {
    return function (n2) {
        return n1 + n2;
    }
}

커링
const add10 = add(10); 기본 10으로 저장된 곳에 매개변수를 더해주는?
add(10)을 실행하면 add10이라는 함수를 반환해서 아래서 처럼 사용할 수 있는
add10(20); >>> 30
add10(30); >>> 40



/////
문제가 추가를 하면 삭제가 안댐 코드가 실행이 되는 시점은 브라우저가 로딩이 되는
시점에 실행이 됨 그렇기 때문에 추가된 항목에 대해서는 이벤트 등록 시점에 없는 태그!
이것을 등록 하기

//추가된 아이템의 삭제 버튼에 이벤트 등록
    $newItem.querySelector('.remove').onclick = function () {
        $newItem.remove();


//함수로 정리

 $remove.parentNode.remove();
 >>
    function removeItem(event){
        event.target.remove.parentNode.remove();

완료된 태그의 특징!


// 질문 : 수정 취소 까지만 가능하고 수정이 된 내용은 등록이 되는게 아닌가?

html을 새로 넣어주었을 때 이벤트까지 다시 등록을 해주어야한다
html이 들어가는 시점 / 생성되는 시점에 이벤트의 유무에 따라 동작이 결정
브라우저는 이벤트의 유무에 따라서 동작이 결정

